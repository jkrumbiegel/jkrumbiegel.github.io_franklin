<!doctype html> <html lang=en > <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <script async src="https://www.googletagmanager.com/gtag/js?id=G-W5JSWMN3EQ"></script> <script> window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-W5JSWMN3EQ'); </script> <link rel=stylesheet  href="/libs/highlight/julius.custom.css"> <link rel=stylesheet  href="/css/franklin.css"> <link rel=stylesheet  href="/css/basic.css"> <link rel=stylesheet  href="/css/custom.css"> <title>Tuples and Vectors, Allocations and Performance for Beginners</title> <header> <div class=blog-name ><a href="/">thoughts & priors</a></div> <nav> <ul> <li><a href="/">Home</a> <li><a href="/photography">Photography</a> </ul> <img src="/assets/hamburger.svg" id=menu-icon > </nav> </header> <div class=franklin-content ><h1 id=tuples_and_vectors_allocations_and_performance_for_beginners ><a href="#tuples_and_vectors_allocations_and_performance_for_beginners" class=header-anchor >Tuples and Vectors, Allocations and Performance for Beginners</a></h1> <p>If you&#39;re new to Julia, here is a scenario that might have tripped you up already:</p> <p>Let&#39;s define two points. Both are just a collection of two floating point numbers. But one is a <code>Vector</code>, written with the <code>&#91;&#93;</code> syntax, and one a <code>Tuple</code>, written with the <code>&#40;&#41;</code> syntax.</p> <p>Then we make vectors of both types of points and run a short computation. Let&#39;s see what the performance difference looks like.</p> <pre><code class=language-julia >rand_vector_point&#40;&#41; &#61; &#91;rand&#40;&#41;, rand&#40;&#41;&#93; # note the &#91;&#93;
rand_tuple_point&#40;&#41;  &#61; &#40;rand&#40;&#41;, rand&#40;&#41;&#41; # note the &#40;&#41;

# create vectors of 500 random points each
vector_points &#61; &#91;rand_vector_point&#40;&#41; for _ in 1:500&#93;
tuple_points  &#61; &#91;rand_tuple_point&#40;&#41;  for _ in 1:500&#93;

# define a simple function calculating pairwise differences
function difference_matrix&#40;points&#41;
    &#91;p1 .- p2 for p1 in points, p2 in points&#93;
end

# run each version once, just to get compilation out of the way
difference_matrix&#40;vector_points&#41;
difference_matrix&#40;tuple_points&#41;

println&#40;&quot;Vector version:&quot;&#41;
@time difference_matrix&#40;vector_points&#41;
println&#40;&quot;Tuple version:&quot;&#41;
@time difference_matrix&#40;tuple_points&#41;</code></pre> <pre><code class=language-julia >Vector version:
  0.017412 seconds &#40;250.00 k allocations: 24.796 MiB&#41;
Tuple version:
  0.002698 seconds &#40;2 allocations: 3.815 MiB&#41;</code></pre> <p>The Vector version is much slower than the Tuple version. But why? Are Vectors bad and Tuples good?</p> <p>In the following post I&#39;ll try to explain in simple terms why we see such a big difference and how you can use your new knowledge to write better code in Julia.</p> <h2 id=allocations ><a href="#allocations" class=header-anchor >Allocations</a></h2> <p>The <code>@time</code> outputs show that there were 250,000 allocations for the vector version and only 2 for the tuple version. What does that mean and why does it make the code slow?</p> <p>An allocation is a request for memory. Our program tells the operating system &quot;I need space to store some values&quot; and the operating system gives back the location of some empty space in our RAM we can use.</p> <p>Asking the operating system for memory takes time, therefore more allocations make our code slower. So far, so good.</p> <p>In the vector case, this happened 250,000 times, or once for each entry in the 500 x 500 distance matrix. In the tuple code it happened only twice.</p> <p>But isn&#39;t that weird?</p> <p>In both cases, each point consists of two floating point numbers. Each computation generates the exact same number of points. So why do we need to ask for more memory in the vector version?</p> <p>This leads us to the next important piece of the puzzle: We need to look at what the stack and the heap are.</p> <h2 id=stack_and_heap ><a href="#stack_and_heap" class=header-anchor >Stack And Heap</a></h2> <p>Many programming languages work with two concepts called the <em>stack</em> and the <em>heap</em>. These concepts are just two different ways of organizing memory, which influence the speed with which programs run.</p> <p>The heap is comparable to a big space where stored objects are scattered all over the place. Some objects are big, some are small, and there may be large or small gaps between them. The heap is a bit messy, but it is also spacious. If you want to store a new object there, the operating system finds a suitable location for you and gives you the address.</p> <p>The stack on the other hand has a very strict order. It&#39;s like a tower of objects which are stacked neatly in memory, one on top of the other. There are no gaps between them, and you can&#39;t just pull out objects from the middle. You can only take off the topmost object or stack new ones on top of that one. New objects are always stored on top, never anywhere else.</p> <p>Why do we have the two kinds?</p> <p>The heap is for all objects that can dynamically change in size and for objects that should live longer in memory. If you need more or less space for some object which is on the heap, you can maybe expand it into some empty space around it, or you have to find a new place and copy it there. The stack on the other hand can only be built out of objects that never change in size. Imagine how that neat tower would react if an object right in the middle suddenly shrank or expanded?</p> <p>That&#39;s not allowed.</p> <p>This might seem restrictive, but on the other hand it makes the stack really fast. Our program always knows where each object in the stack is and what size it has. We also never need to ask the operating system for additional memory when storing things on the stack. That&#39;s because we have preallocated memory for it that should be enough for almost all purposes &#40;as long as we don&#39;t just keep stacking on top without removing things in between, then you get one of the famed stack overflows&#41;.</p> <p>To sum up, using stack memory is much faster than allocating on the heap. The problem is that not every object can be stored on the stack, only those that never change in size can be.</p> <p>How does that relate to our Vectors and Tuples? It&#39;s simple: Vectors are mutable and Tuples are not.</p> <h2 id=mutable_and_immutable_objects ><a href="#mutable_and_immutable_objects" class=header-anchor >Mutable And Immutable Objects</a></h2> <p>At first glance, the two descriptions of a point <code>&#91;rand&#40;&#41;, rand&#40;&#41;&#93;</code> and <code>&#40;rand&#40;&#41;, rand&#40;&#41;&#41;</code> might look really similar, and obviously we could run the same function with both versions. The difference is that the <code>Vector</code> created with <code>&#91;&#93;</code> is mutable, and the <code>Tuple</code> created with <code>&#40;&#41;</code> is immutable.</p> <p>For example this works:</p> <pre><code class=language-julia >vector_point &#61; &#91;1.0, 2.0&#93;
push&#33;&#40;vector_point, 3.0&#41;</code></pre> <pre><code class=language-julia >3-element Array&#123;Float64,1&#125;:
 1.0
 2.0
 3.0</code></pre> <p>And this doesn&#39;t:</p> <pre><code class=language-julia >tuple_point &#61; &#40;1.0, 2.0&#41;
push&#33;&#40;tuple_point, 3.0&#41;</code></pre> <pre><code class=language-julia >ERROR: MethodError: no method matching push&#33;&#40;::Tuple&#123;Float64,Float64&#125;, ::Float64&#41;</code></pre>
<p>Another important difference is the exact type of each object. The vector point is of type <code>Array&#123;Float64,1&#125;</code>, or a one-dimensional array of <code>Float64</code>s. The tuple point is of type <code>Tuple&#123;Float64,Float64&#125;</code>, or a tuple of exactly two <code>Float64</code>s.</p>
<p>Notice the difference? The tuple type guarantees that there are always exactly two elements in our point. The <code>Array&#123;Float64,1&#125;</code> makes no such guarantee.</p>
<p>In Julia, a generic function has a method compiled for each combination of specific types of input arguments that we give it. So the method of <code>difference_matrix&#40;points&#41;</code> where <code>points</code> is a Vector of points of type <code>Array&#123;Float64,1&#125;</code> doesn&#39;t know how many elements such points have, or how much memory will be needed for the resulting points, or even the matrix storing these points. That all has to be determined dynamically. Dynamic is slow&#33;</p>
<p>When the compiler compiles the method of <code>difference_matrix&#40;points&#41;</code> that uses <code>points</code> of type <code>Tuple&#123;Float64, Float64&#125;</code>, it has so much more information. It knows that each point has a specific width in memory. It knows that for each subtraction operation, the exact same size will be needed on the stack. It also knows that the resulting Matrix of points can be stored contiguously in memory.</p>
<p>Contiguous means packed tightly together. We can do that with the tuple points because again we know their size beforehand. With the vector points, we don&#39;t know that. The matrix that stores our vector points actually only stores the addresses for each of the little mutable point vectors. These vectors are then scattered all over the heap, with no guaranteed order that the computer could make use of. This should strike you as a really messy way of dealing with a simple matrix of points, and you would be right. The array of tuples where all points are packed together like sardines is much better.</p>
<p>Notice that the matrix of tuples itself is not stored on the stack, but is stored in contiguous fashion on the heap. As long as we only need one allocation for that big piece of memory, that cost disappears compared to the computations we do with that memory. The 250,000 allocations in the vector case come from each individual <code>Vector</code> that results from the subtraction of two existing <code>Vectors</code>. For the matrix that stores the addresses of those individual vectors we again need only one allocation, because the memory addresses of mutable objects are themselves immutable objects of fixed size...</p>
<h2 id=its_not_just_tuples ><a href="#its_not_just_tuples" class=header-anchor >It&#39;s Not Just Tuples</a></h2>
<p>The mechanism explained above is not specific to tuples. It works with basically every immutable data structure that has a fixed size in memory given its type. For example, we could define a point as an immutable struct containing exactly two <code>Float64</code>s and would enjoy similar benefits:</p>
<pre><code class=language-julia >struct Point
    x::Float64
    y::Float64
end</code></pre>
<p>Actually, such a point would have the exact same memory footprint as a <code>Tuple&#123;Float64,Float64&#125;</code> and the compiler might even treat them exactly the same on a machine code level.</p>
<p>The important thing is that the type of our point gives the compiler complete information about the size in memory. Often, the compiler depends on knowing the exact type of objects that are stored in a collection. And it&#39;s not immediately better just because that type is a <code>Tuple</code>.</p>
<p>For example, you can store points of type <code>Tuple&#123;Float64, Float64&#125;</code> in a vector with parametric type <code>Tuple&#123;Any,Any&#125;</code>. This basically hides the true identity of our points from the compiler and results in abysmal performance:</p>
<pre><code class=language-julia >anytuple_points  &#61; Tuple&#123;Any,Any&#125;&#91;rand_tuple_point&#40;&#41;  for _ in 1:500&#93;

println&#40;&quot;We have hidden our points in an &#36;&#40;typeof&#40;anytuple_points&#41;&#41;&quot;&#41;

difference_matrix&#40;anytuple_points&#41;

println&#40;&quot;AnyTuple version:&quot;&#41;
@time difference_matrix&#40;anytuple_points&#41;</code></pre>
<pre><code class=language-julia >We have hidden our points in an Array&#123;Tuple&#123;Any,Any&#125;,1&#125;
AnyTuple version:
  0.109928 seconds &#40;1.75 M allocations: 68.680 MiB, 8.43&#37; gc time&#41;</code></pre>
<p>The instructions the compiler created for <code>Tuple&#123;Any,Any&#125;</code> points are much more bloated, because who knows what those tuples contain? Could it be <code>Float64</code>s by chance? The issue above actually leads to a very important concept in Julia called <em>type stability</em> which is another huge factor influencing performance, but is too much for this post.</p>
<h2 id=stack_those_immutables ><a href="#stack_those_immutables" class=header-anchor >Stack Those Immutables</a></h2>
<p>To conclude this introduction, always check that your types are as concrete as possible, that your data structures can be represented by pure bit patterns and stored on the stack if possible. The function <code>isbits</code> helps to figure out if your objects have those desired properties. For example, <code>isbits&#40;&#91;1, 2&#93;&#41; &#61;&#61; false</code> but <code>isbits&#40;&#40;1, 2&#41;&#41; &#61;&#61; true</code>.</p>
<p>You might never really have encountered immutable data structures if you come from languages like R or Matlab, but they are a big reason why Julia code can be so much faster, so make use of them&#33; If you deal with data structures of known size, preferably use tuples or immutable structs &#40;or check out <code>StaticArrays.jl</code>, which has tuples dressed up as arrays for convenience&#41;.</p>
<p>You&#39;ll make your compiler&#39;s and therefore your computer&#39;s job much easier, and end up with more efficient and fast code in the process.</p>
<p>This is also not nearly all there is to say about the difference between Tuples and Vectors, but it should hopefully get some of the biggest misconceptions out of the way&#33;</p>
<div class=page-foot >
  <div class=copyright >
    &copy; Julius Krumbiegel. Last modified: June 07, 2021. Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia programming language</a>.
  </div>
</div>
</div>
    
    
        <script src="/libs/highlight/julia.highlight.js"></script>
<script>hljs.initHighlightingOnLoad();hljs.configure({tabReplace: '    '});</script>